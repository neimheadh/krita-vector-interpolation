import sys
sys.path.append('./lib')

import Svg
import os
import unittest


class TestSvg(unittest.TestCase):
    def test_two_path1(self):
        """
        Test two path interpolation from an svg generated by Krita
        """
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_two_path.svg', 'r')
        svg = f.read()
        f.close()

        # Parse SVG content
        parser = Svg.Svg(svg)
        self.assertEqual(len(parser.children), 3, "Svg should have 3 childrens")
        self.assertEqual(parser.el.tag, "{http://www.w3.org/2000/svg}svg", "Svg element should be '<svg>'")
        self.assertEqual(parser.children[0].el.tag, "{http://www.w3.org/2000/svg}defs", "Svg first children should be '<defs>'")
        self.assertEqual(parser.children[1].el.tag, "{http://www.w3.org/2000/svg}path", "Svg second children should be '<path>'")
        self.assertEqual(parser.children[2].el.tag, "{http://www.w3.org/2000/svg}path", "Svg fourth children should be '<path>'")
        self.assertEqual(type(parser.children[0]), Svg.Node.Node, "Svg first children type should be Svg.Node.Node")
        self.assertEqual(type(parser.children[1]), Svg.Node.Path, "Svg second children type should be Svg.Node.Path")
        self.assertEqual(type(parser.children[2]), Svg.Node.Path, "Svg third children type should be Svg.Node.Path")

        # Verify path parsing
        path1 = parser.children[1]
        path2 = parser.children[2]
        for i, path in enumerate([path1, path2]):
            self.assertEqual(len(path.commands), 6, f"Path {i} should have 6 commands")
            self.assertEqual(len(path.transform), 1, f"Path {i} should have one transformation")
            self.assertEqual(path.transform[0].operation, 'translate', f"Path {i} transformation should be a translation")
        self.assertEqual(path1.transform[0].values, [109.151727300548, 46.0618833287889], "Path 1 translation values incorrect")
        self.assertEqual(path2.transform[0].values, [142.184818405752, 276.238867171887], "Path 2 translation values incorrect")

        commands = [
            [
                ['M', 28.6083, 0.0181163],
                ['C', 6.62254, 0.580711, -0.674592, 14.0765, 0.0482714, 27.8581],
                ['C', 0.771884, 41.654, 12.5311, 59.9709, 32.9283, 59.5381],
                ['C', 52.5393, 59.122, 61.9985, 47.9182, 61.9683, 32.1781],
                ['C', 61.942, 18.4897, 55.5682, -0.671763, 28.6083, 0.0181163],
                ['Z']
            ],
            [
                ['M', 14.6552, 0.00112161],
                ['C', 7.08103, -0.181807, 0.419029, 22.0553, 0.0151758, 34.4411],
                ['C', -0.369523, 46.2395, 6.62058, 68.4957, 14.0552, 68.4011],
                ['C', 21.7577, 68.3032, 28.1148, 48.1295, 28.4552, 36.7211],
                ['C', 28.713, 28.0775, 24.7388, 0.244659, 14.6552, 0.00112161],
                ['Z']
            ],
        ]
        for i in range(0, 6):
            for p, path in enumerate([path1, path2]):
                v = [path.commands[i].operation] + path.commands[i].values
                self.assertEqual(v, commands[p][i], f"Path {p} command {i} incorrect")

        # Interpolate
        steps = 5
        intp = parser.interpolate(path1, path2, steps)
        self.assertNotEqual(intp, parser, "Interpolation should generate a new object")
        self.assertEqual(len(intp.children), steps, f"Interpolation should have {steps} children")
        for i, child in enumerate(intp.children):
            self.assertEqual(child.el.tag, '{http://www.w3.org/2000/svg}path', f"Interpolation children {i} should be <path>")

            # Commands new values
            new = []
            p = (i + 1) / (steps + 1)
            for c, command1 in enumerate(commands[0]):
                command2 = commands[1][c]
                n = []
                for j, v1 in enumerate(command1):
                    v2 = command2[j]
                    if j == 0:
                        n.append(v1)
                    else:
                        n.append((v2 - v1) * p + v1)
                new.append(n)
            
            # Test new path command values
            cIntp = []
            for command in child.commands:
                cIntp.append([command.operation] + command.values)
            self.assertEqual(cIntp, new, f'Interpolation {i} commands values invorrect')

            # Test new path transformation
            values = [
                (path2.transform[0].values[0] - path1.transform[0].values[0]) * p + path1.transform[0].values[0],
                (path2.transform[0].values[1] - path1.transform[0].values[1]) * p + path1.transform[0].values[1],
            ]
            self.assertEqual(child.transform[0].operation, 'translate', f'Interpolation {i} transformation should be translate')
            self.assertEqual(child.transform[0].values, values, f'Interpolation {i} translation values incorrect')
            
        # Test string conversion
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_two_path.intp.svg', 'r')
        svg = f.read()
        f.close()
        maxDiff = self.maxDiff
        self.maxDiff = None
        self.assertEqual(intp.toString(), svg, 'Interpolation string conversion incorrect')
        self.maxDiff = maxDiff

        # Test path finding for interpolation
        self.assertTrue(intp.toString(), parser.interpolate('shape0', 'shape1', steps).toString())
        self.assertTrue(intp.toString(), parser.interpolate(1, 2, steps).toString())

        # Test concatened interpolation coherence
        self.assertEqual(3, len(parser.children), 'Svg children have been changed')
        parser.interpolate(1, 2, 2, False)
        self.assertEqual(5, len(parser.children), 'Svg should have 5 children after interpolation concatenation')
    
    def test_empty_svg_parsing(self):
        """ 
        Test empty svg parsing 
        """
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_empty_svg_parsing.svg', 'r')
        svg = f.read()
        f.close()

        parser = Svg.Svg(svg)
        self.assertEqual(parser.toString(), '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:krita="http://krita.org/namespaces/svg/krita" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" width="297.6pt" height="420.96pt" viewBox="0 0 297.6 420.96" />', 'Empty SVG parsing string incorrect')

    def test_incompatible_path_interpolation(self):
        ''' Test interpolation errors '''
        # Test different command count interpolation error.
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_incompatible_path_interpolation.count.svg', 'r')
        svg = f.read()
        f.close()

        parser = Svg.Svg(svg)

        err = False
        try:
            parser.interpolate(1, 2, 2)
        except RuntimeError as e:
            err = e
        self.assertEqual(type(err), RuntimeError, 'Runtime error should be thrown')
        self.assertRegex(str(err), r'^Nodes are not compatible for interpolation', 'Runtime error messager incorrect')

        # Test different command operation interpolation error.
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_incompatible_path_interpolation.operation.svg', 'r')
        svg = f.read()
        f.close()

        parser = Svg.Svg(svg)

        err = False
        try:
            parser.interpolate(1, 2, 2)
        except RuntimeError as e:
            err = e
        self.assertEqual(type(err), RuntimeError, 'Runtime error should be thrown')
        self.assertRegex(str(err), r'^Nodes are not compatible for interpolation', 'Runtime error messager incorrect')

        # Test different type interpolation error.
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_two_path.svg', 'r')
        svg = f.read()
        f.close()

        parser = Svg.Svg(svg)

        err = False
        try:
            parser.interpolate(1,0, 2)
        except RuntimeError as e:
            err = e
        self.assertEqual(type(err), RuntimeError, 'Runtime error should be thrown')
        self.assertRegex(str(err), r'^Nodes are not compatible for interpolation', 'Runtime error messager incorrect')

    def test_path_toString(self):
        """Test path string conversion"""
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_two_path.svg', 'r')
        svg = f.read()
        f.close()

        parser = Svg.Svg(svg)
        path = parser.children[1]
        
        self.assertEqual(path.toString(), '<{http://www.w3.org/2000/svg}path transform="translate(109.151727300548, 46.0618833287889)" fill="none" stroke="#ff0000" stroke-width="0.24" stroke-linecap="square" stroke-linejoin="bevel" d="M 28.6083 0.0181163C 6.62254 0.580711 -0.674592 14.0765 0.0482714 27.8581C 0.771884 41.654 12.5311 59.9709 32.9283 59.5381C 52.5393 59.122 61.9985 47.9182 61.9683 32.1781C 61.942 18.4897 55.5682 -0.671763 28.6083 0.0181163Z" {http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd}nodetypes="cssss" />', 'Path direct toString incorrect')
        self.assertEqual(path.toString(parser.getXmlns()), '<path transform="translate(109.151727300548, 46.0618833287889)" fill="none" stroke="#ff0000" stroke-width="0.24" stroke-linecap="square" stroke-linejoin="bevel" d="M 28.6083 0.0181163C 6.62254 0.580711 -0.674592 14.0765 0.0482714 27.8581C 0.771884 41.654 12.5311 59.9709 32.9283 59.5381C 52.5393 59.122 61.9985 47.9182 61.9683 32.1781C 61.942 18.4897 55.5682 -0.671763 28.6083 0.0181163Z" sodipodi:nodetypes="cssss" />', 'Xmlns replacement path toString() incorrect')
        self.assertEqual(path.toString(parser.getXmlns(), True), '<path xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:krita="http://krita.org/namespaces/svg/krita" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" transform="translate(109.151727300548, 46.0618833287889)" fill="none" stroke="#ff0000" stroke-width="0.24" stroke-linecap="square" stroke-linejoin="bevel" d="M 28.6083 0.0181163C 6.62254 0.580711 -0.674592 14.0765 0.0482714 27.8581C 0.771884 41.654 12.5311 59.9709 32.9283 59.5381C 52.5393 59.122 61.9985 47.9182 61.9683 32.1781C 61.942 18.4897 55.5682 -0.671763 28.6083 0.0181163Z" sodipodi:nodetypes="cssss" />', 'Xmlns inclusion path toString() incorrect')

    def test_transform_dismorphism(self):
        """Test transform dismorphism"""
        
        # Test interpolation when path2 has no transform
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_transform_dismorphism.svg', 'r')
        svg = f.read()
        f.close()
        parser = Svg.Svg(svg)

        intp = parser.interpolate(1, 0, 1)
        self.assertEqual(intp.children[0].transform[0].values[0], 50, 'Interpolated transform first value should be 50')
        self.assertEqual(intp.children[0].transform[0].values[1], 25, 'Interpolated transform second value should be 25')

        intp = parser.interpolate(0, 2, 1)
        self.assertEqual(intp.children[0].transform[0].values[0], 100, 'Interpolated transform first value should be 100')
        self.assertEqual(intp.children[0].transform[0].values[1], 25, 'Interpolated transform second value should be 25')

    def test_face(self):
        """Test test_face.svg interpolations"""
        f = open(os.path.dirname(os.path.realpath(__file__)) + '/assets/test_face.svg', 'r')
        svg = f.read()
        f.close()
        parser = Svg.Svg(svg)

        # Test interpolate 1/4 face left eye to full face left eye
        intp = parser.interpolate("shape2", "shape3", 1)
        self.assertEqual(intp.children[0].transform[0].operation, 'matrix', 'Interpolation transform should be a matrix')
        self.assertEqual(intp.children[0].transform[0].values, [1.1636557947061799, 0.0, 0.0, 0.993835549478444, 841.2003324608875, 585.2269691975885], 'Interpolation transform matrix values incorrect')

        # Should be the same when we reverse inputs
        intp = parser.interpolate("shape3", "shape2", 1)
        self.assertEqual(intp.children[0].transform[0].operation, 'matrix', 'Interpolation transform should be a matrix')
        self.assertEqual(intp.children[0].transform[0].values, [1.1636557947061799, 0.0, 0.0, 0.993835549478444, 841.2003324608875, 585.2269691975885], 'Interpolation transform matrix values incorrect')


if __name__ == '__main__':
    unittest.main()